
// Its own header file:
#include "DimensionSelectionWidget.h"

#include "DimensionSelectionHolder.h"
#include "DimensionSelectionItemModel.h"
#include "DimensionSelectionProxyModel.h"
#include "ModelResetter.h"
#include "PointData.h"

// Qt header files:
#include <QAbstractEventDispatcher>
#include <QApplication>
#include <QClipboard>
#include <QDebug>
#include <QFileDialog>
#include <QMenu>
#include <QMessageBox>
#include <QSortFilterProxyModel>
#include <QString>
#include <QTime>

// Standard C++ header files:
#include <algorithm>
#include <cmath>
#include <execution>
#include <limits>
#include <vector>

// Header file, generated by Qt User Interface Compiler:
#include <ui_DimensionSelectionWidget.h>
#include <set>


namespace hdps
{
    namespace
    {
        QString getSelectionFileFilter()
        {
            return QObject::tr("Text files (*.txt);;All files (*.*)");
        }


        template <typename T>
        void connectButtonClicked(QAbstractButton& button, const T slot)
        {
            QObject::connect(&button, &QAbstractButton::clicked, [slot, &button]
            {
                try
                {
                    slot();
                }
                catch (const std::exception& stdException)
                {
                    qCritical()
                        << "Exception \""
                        << typeid(stdException).name()
                        << "\" on "
                        << button.text()
                        << " button click: "
                        << stdException.what();
                }
            });
        }


        template <typename T>
        void connectButtonToggled(QAbstractButton& button, const T slot)
        {
            QObject::connect(&button, &QAbstractButton::toggled, [slot, &button](const bool checked)
            {
                try
                {
                    slot(checked);
                }
                catch (const std::exception& stdException)
                {
                    qCritical()
                        << "Exception \""
                        << typeid(stdException).name()
                        << "\" on "
                        << button.text()
                        << " button toggle: "
                        << stdException.what();
                }
            });
        }


        void readSelectionFromFile(QFile& file, DimensionSelectionHolder& holder)
        {
            holder.disableAllDimensions();

            while (!file.atEnd())
            {
                const auto timmedLine = file.readLine().trimmed();

                if (!timmedLine.isEmpty())
                {
                    const auto name = QString::fromUtf8(timmedLine);

                    if (!holder.tryToEnableDimensionByName(name))
                    {
                        qWarning() << "Failed to select dimension (name not found): " << name;
                    }
                }
            }
        }


        void readSelectionFromFile(const QString& fileName, QAbstractItemModel* const itemModel, DimensionSelectionHolder& holder)
        {
            if (!fileName.isEmpty())
            {
                QFile file(fileName);

                if (file.open(QIODevice::ReadOnly | QIODevice::Text))
                {
                    const ModelResetter modelResetter(itemModel);
                    readSelectionFromFile(file, holder);
                }
                else
                {
                    qCritical() << "Load failed to open file: " << fileName;
                }
            }
        }


        void readExclusionFromFile(const QString& fileName, DimensionSelectionProxyModel& proxyModel)
        {
            if (!fileName.isEmpty())
            {
                QFile file(fileName);

                if (file.open(QIODevice::ReadOnly | QIODevice::Text))
                {
                    const ModelResetter modelResetter(&proxyModel);

                    std::deque<QString> strings;

                    while (!file.atEnd())
                    {
                        const auto trimmedLine = file.readLine().trimmed();

                        if (!trimmedLine.isEmpty())
                        {
                            strings.push_back(QString::fromUtf8(trimmedLine));
                        }
                    }

                    proxyModel.SetExclusion(std::vector<QString>(strings.cbegin(), strings.cend()));

                }
                else
                {
                    qCritical() << "Load exclusion failed to open file: " << fileName;
                }
            }
        }

        void writeSelectionToFile(const QString& fileName, const DimensionSelectionHolder& holder)
        {
            if (!fileName.isEmpty())
            {
                QFile file(fileName);

                if (file.open(QIODevice::WriteOnly | QIODevice::Text))
                {
                    const auto numberOfDimensions = holder.getNumberOfDimensions();

                    for (std::size_t i{}; i < numberOfDimensions; ++i)
                    {
                        if (holder.isDimensionEnabled(i))
                        {
                            file.write(holder.getName(i).toUtf8());
                            file.write("\n");
                        }
                    }
                }
                else
                {
                    qCritical() << "Save failed to open file: " << fileName;
                }
            }
        }

        void CopyModelToClipboard(const QAbstractItemModel& model)
        {
            
            QString result;
            const auto quote = QChar::fromLatin1('"');
            const auto tabChar = QChar::fromLatin1('\t');
            const auto linebreakChar = QChar::fromLatin1('\n');

            const auto columnCount = model.columnCount();

            for (int columnIndex = 0; columnIndex < columnCount; ++columnIndex)
            {
                if (columnIndex != 0)
                {
                    result += tabChar;
                }

                QString header = model.headerData(columnIndex, Qt::Horizontal).toString();
                result += quote + header + quote;
            }
            result += linebreakChar;

            const auto rowCount = model.rowCount();

            for (int rowIndex = 0; rowIndex < rowCount; ++rowIndex)
            {
                for (int columnIndex = 0; columnIndex < columnCount; ++columnIndex)
                {
                    if (columnIndex != 0)
                    {
                        result += tabChar;
                    }

                    result += model.data(model.index(rowIndex, columnIndex)).toString();
                }
                result += linebreakChar;
            }
            QApplication::clipboard()->setText(result);

        }

    }  // End of namespace.


    class DimensionSelectionWidget::Impl
    {
    public:
        const Ui_DimensionSelectionWidget _ui;

        DimensionSelectionHolder _holder;

        std::unique_ptr<DimensionSelectionItemModel> _dimensionSelectionItemModel;
        std::unique_ptr<DimensionSelectionProxyModel> _proxyModel;

        QMetaObject::Connection m_awakeConnection;

        const Points* _pointData = nullptr;

    private:
        void updateLabel()
        {
            const auto& holder = _holder;
            const auto numberOfDimensions = holder.getNumberOfDimensions();
            const int numberOfVisibleDimensions = (_proxyModel == nullptr) ?
                0 : _proxyModel->rowCount();

            _ui.label->setText(QObject::tr("%1 available, %2 visible, %3 selected").
                arg(numberOfDimensions).
                arg(numberOfVisibleDimensions).
                arg(holder.getNumberOfSelectedDimensions()) );
        }

        void updateSlider()
        {
            auto& slider = *(_ui.horizontalSlider);
            const auto numberOfDistinctStandardDeviations = _holder.distinctStandardDeviationsWithAndWithoutZero[_holder._ignoreZeroValues ? 1 : 0].size();
            const bool isSliderValueAtMaximum = (slider.value() == slider.maximum());

            if ((numberOfDistinctStandardDeviations > 0) && (numberOfDistinctStandardDeviations <= std::numeric_limits<int>::max()))
            {
                const auto newMaximum = static_cast<int>(numberOfDistinctStandardDeviations) - 1;
                if (newMaximum != slider.maximum())
                {
                    slider.setMaximum(newMaximum);
                    qDebug() << "Dimension Selection slider maximum value: " << newMaximum;
                }
                slider.setValue(isSliderValueAtMaximum ? newMaximum : 0);
            }
            else
            {
                slider.setValue(isSliderValueAtMaximum ? 1 : 0);
                slider.setMaximum(1);
            }
        }

        template <bool selectVisible>
        void selectDimensionsBasedOnVisibility()
        {
            const auto n = _holder.getNumberOfDimensions();

            if (n > INT_MAX)
            {
                assert(!"Number of dimensions too large -- Qt uses int!");
            }
            else
            {
                for (unsigned i{}; i < n; ++i)
                {
                    _holder.setDimensionEnabled(i, _proxyModel->filterAcceptsRow(i, QModelIndex()) == selectVisible);
                }
                const ModelResetter modelResetter(_proxyModel.get());
            }
        }

    public:
        Impl(QWidget& widget)
            :
            _ui([&widget]
        {
            Ui_DimensionSelectionWidget ui{};
            ui.setupUi(&widget);
            return ui;
        }())
        {
            if (QHeaderView *const header = _ui.tableView->verticalHeader(); header != nullptr)
            {
                // Reduce height of cells by 33%. The cells were really too high, originally!
                header->setSectionResizeMode(QHeaderView::Fixed);
                const auto originalDefaultSectionSize = header->defaultSectionSize();
                header->setDefaultSectionSize((2 * originalDefaultSectionSize)/3);
            }

            if (QHeaderView *const header = _ui.tableView->horizontalHeader(); header != nullptr)
            {
                // Especially the header text looks much better, when left-aligned.
                header->setDefaultAlignment(Qt::AlignLeft);
            }

            updateLabel();

            connectButtonClicked(*_ui.loadPushButton, [this, &widget]
            {
                const auto fileName = QFileDialog::getOpenFileName(&widget,
                    QObject::tr("Dimension selection"), {}, getSelectionFileFilter());
                readSelectionFromFile(fileName, _proxyModel.get(), _holder);
            });

            connectButtonClicked(*_ui.savePushButton, [this, &widget]
            {
                const auto fileName = QFileDialog::getSaveFileName(&widget,
                    QObject::tr("Dimension selection"), {}, getSelectionFileFilter());
                writeSelectionToFile(fileName, _holder);
            });

            connectButtonClicked(*_ui.computeStatisticsPushButton, [this]
            {
                const ModelResetter modelResetter(_proxyModel.get());

                auto& statistics = _holder._statistics;
                statistics.clear();

                if (_pointData != nullptr)
                {
                    QTime time;

                    time.start();
                    const auto& pointData = *_pointData;

                    pointData.visitFromBeginToEnd([&statistics, &pointData](auto beginOfData, auto endOfData)
                        {
                            const auto numberOfDimensions = pointData.getNumDimensions();
                            const auto numberOfPoints = pointData.getNumPoints();

                            constexpr static auto quiet_NaN = std::numeric_limits<double>::quiet_NaN();

                            if (numberOfPoints == 0)
                            {
                                statistics.resize(numberOfDimensions, { quiet_NaN, quiet_NaN, quiet_NaN, quiet_NaN });
                            }
                            else
                            {
                                statistics.resize(numberOfDimensions);
                        const auto* const statisticsData = statistics.data();

                                if (numberOfPoints == 1)
                                {
                            (void)std::for_each_n(std::execution::par_unseq, statistics.begin(), numberOfDimensions,
                                        [statisticsData, beginOfData](auto& statisticsPerDimension)
                                        {
                                            const auto i = &statisticsPerDimension - statisticsData;
                                
                                            const double dataValue = beginOfData[i];
                                            statisticsPerDimension = { {dataValue, dataValue}, {quiet_NaN, quiet_NaN} };
                                        });
                                }
                                else
                                {
                                    (void)std::for_each_n(std::execution::par_unseq, statistics.begin(), numberOfDimensions,
                                        [statisticsData, numberOfDimensions, numberOfPoints, beginOfData](auto& statisticsPerDimension)
                                        {
                                            const std::unique_ptr<double[]> data(new double[numberOfPoints]);
                                            {
                                                const auto i = &statisticsPerDimension - statisticsData;

                                                for (unsigned j{}; j < numberOfPoints; ++j)
                                                {
                                                    data[j] = beginOfData[j * numberOfDimensions + i];
                                                }
                                            }

                                            double sum{};
                                            unsigned numberOfNonZeroValues{};

                                            for (unsigned j{}; j < numberOfPoints; ++j)
                                            {
                                                const auto value = data[j];

                                                if (value != 0.0)
                                                {
                                                    sum += value;
                                                    ++numberOfNonZeroValues;
                                                }
                                            }
                                            const auto mean = sum / numberOfPoints;

                                            double sumOfSquares{};

                                            for (unsigned j{}; j < numberOfPoints; ++j)
                                            {
                                                const auto value = data[j] - mean;
                                                sumOfSquares += value * value;
                                            }

                                            static_assert(quiet_NaN != quiet_NaN);

                                            statisticsPerDimension = StatisticsPerDimension
                                            {
                                                {
                                                    mean,
                                                    (numberOfNonZeroValues == 0) ? quiet_NaN : (sum / numberOfNonZeroValues)
                                                },
                                                {
                                                    std::sqrt(sumOfSquares / (numberOfPoints - 1)),
                                                    (numberOfNonZeroValues == 0) ? quiet_NaN : std::sqrt(sumOfSquares / numberOfNonZeroValues)
                                                }
                                            };
                                        });
                                }
                            }
                        });
                    qDebug()
                        << " Duration: " << time.elapsed() << " microsecond(s)";

                    for (unsigned i{}; i <= 1; ++i)
                    {
                        std::set<double> distinctStandardDeviations;

                        for (const auto& statisticsPerDimension : _holder._statistics)
                        {
                            if (!std::isnan(statisticsPerDimension.standardDeviation[i]))
                            {
                                distinctStandardDeviations.insert(statisticsPerDimension.standardDeviation[i]);
                            }
                        }

                        _holder.distinctStandardDeviationsWithAndWithoutZero[i].assign(distinctStandardDeviations.cbegin(), distinctStandardDeviations.cend());
                    }

                    assert(_ui.horizontalSlider->minimum() == 0);
                    updateSlider();
                }

            });

            connectButtonClicked(*_ui.selectVisibleDimensionsPushButton, [this]
            {
                selectDimensionsBasedOnVisibility<true>();
            });

            connectButtonClicked(*_ui.selectNonVisibleDimensionsPushButton, [this]
            {
                selectDimensionsBasedOnVisibility<false>();
            });

            connectButtonClicked(*_ui.loadExclusionListPushButton, [this, &widget]
            {
                if (_proxyModel != nullptr)
                {
                    const auto fileName = QFileDialog::getOpenFileName(&widget,
                        QObject::tr("Exclusion list"), {}, getSelectionFileFilter());

                    readExclusionFromFile(fileName, *_proxyModel);
                }
            });

            connectButtonToggled(*_ui.applyExclusionListCheckBox, [this, &widget](const bool checked)
            {
                if (_proxyModel != nullptr)
                {
                    const ModelResetter modelResetter(&*_proxyModel);
                    _proxyModel->SetFilterShouldAppyExclusion(checked);

                }
            });

            connectButtonToggled(*_ui.showOnlySelectedDimensionsCheckBox, [this, &widget](const bool checked)
            {
                if (_proxyModel != nullptr)
                {
                    const ModelResetter modelResetter(&*_proxyModel);
                    _proxyModel->SetFilterShouldAcceptOnlySelected(checked);
                }
            });


            assert(_ui.tableView->contextMenuPolicy() == Qt::CustomContextMenu);

            connect(_ui.tableView, &QWidget::customContextMenuRequested, [this](const QPoint&)
            {
                if (_proxyModel != nullptr)
                {
                    QMenu menu;

                    menu.addAction(tr("Copy table"), [this] {CopyModelToClipboard(*_proxyModel); });
                    menu.exec(QCursor::pos());
                }
            }
            );

            connectButtonToggled(*_ui.ignoreZeroValuesCheckBox, [this](const bool checked)
            {
                const ModelResetter modelResetter(_proxyModel.get());
                _holder._ignoreZeroValues = checked;
                updateSlider();
            });

            connect(_ui.nameMatchesLineEdit, &QLineEdit::textChanged, [this](const QString & text)
            {
                if (_proxyModel != nullptr)
                {
                    const ModelResetter modelResetter(&*_proxyModel);
                    _proxyModel->setFilterRegExp(text);
                }
            });

            connect(_ui.horizontalSlider, &QSlider::valueChanged, [this](const int sliderValue)
            {
                const auto sliderMaximum = _ui.horizontalSlider->maximum();

                if ((sliderValue >= 0) && (sliderValue <= sliderMaximum) )
                {
                    const auto& distinctStandardDeviations = _holder.distinctStandardDeviationsWithAndWithoutZero[_holder._ignoreZeroValues ? 1 : 0];
                    const auto numberOfDistinctStandardDeviations = distinctStandardDeviations.size();

                    if ((numberOfDistinctStandardDeviations > 0) && (sliderMaximum > 0))
                    {
                        if ((sliderMaximum + 1) == numberOfDistinctStandardDeviations)
                        {
                            const ModelResetter modelResetter(_proxyModel.get());

                            _proxyModel->SetMinimumStandardDeviation(distinctStandardDeviations[sliderValue]);
                        }
                        else
                        {
                            assert(!"Slider maximum incorrect!");
                        }
                    }
                }
                else
                {
                    assert(!"Slider value out of range!");
                }
            });


            // Reset the view "on idle".
            m_awakeConnection = connect(
                QAbstractEventDispatcher::instance(),
                &QAbstractEventDispatcher::awake,
                [this]
            {
                updateLabel();
            });
        }


        ~Impl()
        {
            disconnect(m_awakeConnection);
        }


        void setDimensions(
            const unsigned numberOfDimensions, const std::vector<QString>& names)
        {
            if (names.size() == numberOfDimensions)
            {
                _holder = DimensionSelectionHolder(
                    names.data(),
                    numberOfDimensions);

            }
            else
            {
                assert(names.empty());
                _holder = DimensionSelectionHolder(numberOfDimensions);
            }
            auto dimensionSelectionItemModel = std::make_unique<DimensionSelectionItemModel>(_holder);
            auto proxyModel = std::make_unique<DimensionSelectionProxyModel>(_holder);
            proxyModel->setSourceModel(&*dimensionSelectionItemModel);
            _ui.tableView->horizontalHeader()->setSortIndicator(-1, Qt::AscendingOrder);
            _ui.tableView->setModel(&*proxyModel);
            _proxyModel = std::move(proxyModel);
            updateSlider();
            _dimensionSelectionItemModel = std::move(dimensionSelectionItemModel);
        }


        std::vector<bool> getEnabledDimensions() const
        {
            return _holder.getEnabledDimensions();
        }


        void dataChanged(const Points& points)
        {
            _pointData = &points;
            const auto numberOfDimensions = points.getNumDimensions();
            setDimensions(numberOfDimensions, points.getDimensionNames());
        }
    };


    DimensionSelectionWidget::DimensionSelectionWidget()
        :
        _pImpl(std::make_unique<Impl>(*this))
    {
    }

    DimensionSelectionWidget::~DimensionSelectionWidget() = default;


    void DimensionSelectionWidget::dataChanged(const Points& points)
    {
        _pImpl->dataChanged(points);
    }

    std::vector<bool> DimensionSelectionWidget::getEnabledDimensions() const
    {
        return _pImpl->getEnabledDimensions();
    }

} // namespace hdps
